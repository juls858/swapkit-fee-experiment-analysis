# SwapKit: Cross-Chain DeFi Infrastructure Decoded

SwapKit is an open-source SDK and REST API developed by THORSwap that enables seamless cross-chain cryptocurrency swaps across **30+ blockchains and 10,000+ crypto assets**. The platform aggregates liquidity from multiple decentralized protocols (THORChain, Chainflip, Maya Protocol, NEAR Intents) and DEX aggregators (Uniswap, 1inch, Jupiter), allowing developers to integrate native cross-chain swap functionality in under 100 lines of code. SwapKit's business model centers on charging **10-15 basis points** (0.1%-0.15%) on swaps between gas assets and stablecoins, while enabling integrators to collect customizable affiliate fees. Launched in August 2023, the platform now powers 50+ major crypto applications including Ledger Live, Trust Wallet, and BitPay, processing cross-chain transactions through a sophisticated routing engine that evaluates multiple liquidity sources to deliver optimal pricing in single-signature transactions.

## From THORSwap's infrastructure to DeFi's routing layer

SwapKit emerged from THORSwap's evolution as a cross-chain DEX aggregator. THORSwap initially launched as BEPSwap in summer 2020 alongside THORChain's single-chain chaosnet, then rebranded to THORSwap in April 2021 when THORChain expanded to multi-chain support. By 2023, THORSwap had built sophisticated cross-chain swap technology for its own DEX and decided to package this infrastructure as a standalone B2B product. SwapKit represents THORSwap's strategic move to enable other developers and protocols to access the same battle-tested technology that powers THORSwap's frontend.

The core problem SwapKit solves is **integration complexity** in the fragmented multi-chain DeFi ecosystem. Integrating cross-chain swap functionality directly with protocols like THORChain, Chainflip, and Maya Protocol typically requires hundreds of developer hours, deep protocol knowledge, and months of development to handle multiple protocol APIs, routing logic, and liquidity sources. SwapKit abstracts this complexity into a unified interface, allowing platforms to go "multi-chain in less than 100 lines of code" and integrate cross-chain functionality in days instead of months.

The platform offers three main products: the **SwapKit SDK** (a modular TypeScript/JavaScript package supporting 20+ wallet types), the **SwapKit API** (REST endpoints for quote generation, routing, transaction tracking, and AML compliance), and a **drop-in widget** (pre-built UI components). All three options provide access to the same underlying routing engine and liquidity aggregation capabilities, with the SDK offering the most flexibility and the widget enabling the fastest integration.

SwapKit's revenue model combines platform fees with an affiliate program. The platform charges **10-15 basis points dynamically** based on transaction size, but only on swaps between gas assets (BTC, ETH, AVAX, SOL, XRP, TRX, ATOM, NEAR, BNB, ZEC, RUNE, LTC, BCH, DOGE) and stablecoins (USDC, USDT). Notably, no SwapKit fees apply to other swap pairs like ERC-20 to ERC-20 trades. Fees are automatically collected via transparent on-chain router smart contracts, eliminating settlement and remittance complexity. The affiliate fee program allows integrators to set their own fees in basis points, creating an additional revenue stream—Trust Wallet reportedly earned over $12.7M in affiliate fees in 2024, while Edge Wallet generated $100K through SwapKit integration.

## API structure powers data-driven swap routing

The SwapKit API centers on four primary endpoints that form the core workflow for swap execution and tracking. Understanding these endpoints and their data structures is essential for analyzing BigQuery tables containing swap data.

The **GET /quote** endpoint is the heart of SwapKit's routing engine. This endpoint accepts parameters including `sellAsset` and `buyAsset` (in CHAIN.SYMBOL format), `sellAmount`, `senderAddress`, `recipientAddress`, `slippage` (percentage), optional `providers` filter, and optional `affiliateAddress` and `affiliateBasisPoints` for fee collection. The response returns a `quoteId` (unique identifier like "d21491be-62f3-4f6e-822c-a1e7ef265e46") and a `routes` array ordered by best return amount. Each route represents a complete executable swap path, and the first route in the array is typically the optimal choice based on expected output, total fees, execution time, and reliability.

The QuoteRoute type definition represents the most critical data structure in the SwapKit ecosystem. Each route contains `providers` (an array of main liquidity sources used) and `subProviders` (specific DEX aggregators or sub-protocols), both stored as string arrays. The `path` field provides a human-readable swap description like "ETH.USDT-EC7 → BTC.BTC". Expected outputs are captured in multiple fields: `expectedOutput` (the amount in destination asset), `expectedOutputUSD` (USD equivalent), `expectedOutputMaxSlippage` (worst-case output accounting for slippage tolerance), and `expectedOutputMaxSlippageUSD`. The `estimatedTime` field indicates expected completion in seconds, which varies significantly by provider—THORChain averages around 1,350 seconds (22.5 minutes), while on-chain DEX aggregation completes in seconds.

The fee structure in SwapKit routes uses a nested object organized by chain, making it crucial for BigQuery schema design. Each chain involved in the swap has its own fee array, and each fee object contains several critical fields: `type` (fee type identifier), `asset` (the fee denomination in CHAIN.SYMBOL format), `networkFee` and `networkFeeUSD` (blockchain gas fees), `affiliateFee` and `affiliateFeeUSD` (integrator revenue), `totalFee` and `totalFeeUSD` (sum of all applicable fees), `isOutOfPocket` (boolean indicating whether the fee is deducted from user balance versus taken from output), and optional `slipFee` and `slipFeeUSD` (representing price slippage during execution).

The **swaps** field in each route provides granular detail about the routing path and is particularly important for understanding multi-hop transactions. This field is an object keyed by provider name, where each provider has an array of swap arrays. Each individual swap contains `from` (source asset), `to` (destination asset), `toTokenAddress` (contract address for tokens), and `parts` (an array of routing components). The parts array shows split routing, where each part specifies a `provider` handling that portion and a `percentage` indicating what fraction of the swap flows through that provider. This structure enables SwapKit to split a single swap across multiple DEXs simultaneously for better pricing.

For EVM chains, routes include approval-related fields that are essential for token swaps. The `approvalTarget` specifies which contract address should be approved to spend tokens, while `approvalToken` indicates the token contract requiring approval. These fields only appear for non-native ERC-20 tokens, as native assets like ETH don't require approval. The `evmTransactionDetails` object provides detailed contract interaction information including `contractAddress`, `contractMethod` (like "depositWithExpiry"), `contractParams` (array of parameter values), and `contractParamsNames` (corresponding parameter names). The `calldata` object contains the complete transaction data needed to execute the swap, including vault addresses, asset identifiers, amounts, memos encoding swap instructions, and expiration timestamps.

The **POST /track** endpoint enables real-time monitoring of swap execution across chains. This endpoint requires `hash` (transaction hash), `chainId` (chain identifier), and `block` (typically set to 0 for latest). The response structure mirrors the initial transaction but adds crucial tracking fields: `status` (transaction state), `trackingStatus` (current monitoring state), `finalisedAt` (UNIX timestamp of completion), and most importantly, the `legs` array. Understanding legs is critical for analyzing cross-chain swaps in BigQuery.

**Legs represent individual steps in multi-stage transactions**, particularly for cross-chain swaps that must move through intermediate protocols. Each leg is a complete transaction object with its own `chainId`, `hash`, `type`, `status`, `fromAsset`, `fromAmount`, `toAsset`, `toAmount`, `fromAddress`, `toAddress`, and `finalisedAt` timestamp. For a cross-chain swap like AVAX.AVAX → THOR.RUNE, the first leg occurs on Avalanche (chainId "43114") representing the transfer of AVAX to THORChain's inbound vault address, while the second leg occurs on THORChain (chainId "thorchain-1") representing the actual swap of AVAX for RUNE in THORChain's liquidity pools. The legs array allows tracking of each stage independently, which is essential for debugging failed transactions or understanding where funds are in multi-hop routes.

Transaction status values follow a standardized progression: `not_started` (swap hasn't begun), `pending` (detected in mempool awaiting confirmation), `swapping` (swap in progress), `completed` (successfully finished), `refunded` (returned due to slippage exceeded), `failed` (transaction failed, typically on EVM contracts), and `unknown` (catch-all for edge cases). These statuses apply both to the overall transaction and to individual legs.

## Providers aggregate liquidity across DeFi

In SwapKit's context, **providers are liquidity sources and routing protocols** that the platform aggregates to find optimal swap routes. SwapKit distinguishes between primary cross-chain providers and on-chain DEX aggregator sub-providers, with both types appearing in route responses.

The four primary cross-chain providers are **THORCHAIN** (and THORCHAIN_STREAMING variant), **CHAINFLIP** (and CHAINFLIP_STREAMING), **MAYAPROTOCOL** (or MAYA), and **NEAR** (NEAR Intents, launched June 2025). THORChain remains the flagship cross-chain liquidity protocol supporting 11 chains including Bitcoin, Ethereum, Ripple, BSC, Avalanche, Base, Cosmos, Dogecoin, Litecoin, Bitcoin Cash, and THORChain itself. Chainflip supports 4 chains (BTC, ETH, Solana, Arbitrum) with state-of-the-art cross-chain technology using deposit channels. Maya Protocol, a friendly fork of THORChain, supports 9 chains including some unique additions like Dash, ZCash, Kujira, and Radix. NEAR Intents represents the newest addition, offering the widest coverage with 15+ chains and introducing gas abstraction features where users sign once and relayers handle multi-chain fees.

On-chain DEX aggregator sub-providers handle single-chain swaps and expand SwapKit's token coverage to over 5,500 additional tokens. These include **1inch** (which itself aggregates ParaSwap, GMX, Curve, and others), **Uniswap V2 & V3**, **SushiSwap**, **0x Protocol** (Matcha), **PancakeSwap**, **Jupiter** (Solana's leading aggregator), **Kyber**, **Pangolin**, **TraderJoe**, and **WOOFi**. When requesting quotes, developers can omit the providers parameter to receive quotes from all available sources, or specify one or more providers to filter results. SwapKit's routing engine automatically determines which combination of providers delivers the best execution price after all fees.

The routing algorithm operates through a sophisticated evaluation process. When the /quote endpoint receives a request, it queries multiple providers simultaneously and returns an array of routes ordered by best return amount. Routes are marked with an `optimal` flag indicating the recommended path. The algorithm evaluates routes based on expected output amount (primary criterion), total fees (network + affiliate + slippage), execution time estimates, price impact and slippage tolerance, and liquidity depth across providers. For complex swaps, SwapKit supports **multi-hop routing** where intermediate tokens are used when direct pairs lack liquidity—for example, routing ETH.USDT → ETH → BTC.BTC as a two-hop cross-chain swap. Users only need gas on the originating chain; SwapKit handles all intermediate transactions automatically.

The cross-chain swap mechanics differ by provider. For THORChain-based swaps, users deposit to a THORChain vault address with an encoded memo containing swap instructions; THORChain executes the swap through its liquidity pools and sends the destination asset to the user's target chain address. For Chainflip swaps, users request a quote, open a deposit channel via the `/chainflip/broker/channel` endpoint, deposit assets to the provided channel address, and Chainflip executes the cross-chain swap with output delivered to the destination. For NEAR Intents, users sign an intent message (not a direct blockchain transaction), relayers batch and execute across chains with pre-paid gas, and atomic settlement ensures all-or-nothing execution.

## Asset naming follows strict CHAIN.SYMBOL convention

SwapKit uses a standardized asset identification format critical for database schema design: **CHAIN.SYMBOL[-CONTRACT_ADDRESS]**. The chain identifier indicates the blockchain (BTC, ETH, AVAX, THOR, MAYA, etc.), followed by a period, then the asset symbol, with an optional contract address appended for tokens.

Native assets use simple two-part identifiers: **BTC.BTC** (Bitcoin), **ETH.ETH** (Ethereum native), **AVAX.AVAX** (Avalanche native), **THOR.RUNE** (THORChain's RUNE), **MAYA.CACAO** (Maya Protocol's native token), **BCH.BCH** (Bitcoin Cash), **LTC.LTC** (Litecoin), **DOGE.DOGE** (Dogecoin), **GAIA.ATOM** (Cosmos ATOM), **BSC.BNB** (BNB on BSC), and **DOT.DOT** (Polkadot). ERC-20 and other chain tokens append the contract address: **ETH.USDT-0xdac17f958d2ee523a2206206994597c13d831ec7**, **ETH.USDC-{contract_address}**, **ETH.CRV-{contract_address}**.

Chain identifiers in the asset naming system correspond to specific blockchains: ETH (Ethereum), BTC (Bitcoin), BSC (BNB Smart Chain), AVAX (Avalanche C-Chain), THOR (THORChain), MAYA (Maya Protocol), GAIA (Cosmos Hub), ARB (Arbitrum), OP (Optimism), MATIC (Polygon), DOT (Polkadot), FLIP (Chainflip), KUJI (Kujira), and DASH (Dash). For the /track endpoint, chain IDs use different conventions—numeric for EVM chains ("1" for Ethereum, "43114" for Avalanche), text identifiers for Cosmos chains ("thorchain-1" for THORChain), and chain-specific formats for UTXO chains like Bitcoin.

## Developer integration patterns enable rapid deployment

SwapKit offers two primary integration paths: SDK integration for maximum flexibility or REST API integration for simplicity. The SDK approach uses TypeScript/JavaScript packages installable via npm or bun, with the core `@swapkit/sdk` package providing all-in-one functionality. Developers can take a granular approach for frontend applications by importing only needed plugins (ThorchainPlugin, EVMPlugin, etc.) and wallet adapters (evmWallet, ledgerWallet, etc.), reducing bundle size. The SDK's modular architecture includes core packages (@swapkit/core, @swapkit/api, @swapkit/helpers), protocol plugins (@swapkit/thorchain, @swapkit/chainflip, @swapkit/maya), wallet adapters for 20+ wallet types, and chain-specific toolboxes for EVM, UTXO, Cosmos, and Substrate chains.

The REST API integration follows a simpler pattern centered on the production endpoint at `https://api.swapkit.dev`. All requests require an `x-api-key` header for authentication and a `Referer` header identifying the integrating project. The typical API workflow involves: calling GET /providers to discover available liquidity sources (cacheable), calling GET /tokens to fetch supported token metadata (cacheable), calling POST /quote with swap parameters to receive routes, optionally calling POST /screen for AML compliance checks, executing the transaction using the returned transaction object, and calling POST /track periodically to monitor swap progress.

Common integration patterns include the **quote and execute flow** where developers first request a quote, select the best route (typically `routes[0]`), check and approve token spending if needed (for ERC-20 tokens), and execute the swap using SwapKit's swap method or by signing the returned transaction object directly. The **multi-chain wallet management pattern** enables connecting multiple chains simultaneously, querying balances across chains, and managing wallets for different blockchains from a single interface. The **fee estimation pattern** allows calculating expected gas costs before execution based on transaction type and fee speed preference.

Over 50 protocols have integrated SwapKit, including major platforms that demonstrate the technology's production readiness. **Ledger Live** integrated native Bitcoin cross-chain swaps directly into their hardware wallet application. **Trust Wallet** uses SwapKit for multi-chain swaps with self-custody, drastically simplifying their complex systems according to their team. **Edge Wallet** reported saving "several man-months of engineering work" by integrating SwapKit's THORChain DEX aggregation functionality. **BitPay Wallet** leverages SwapKit for competitive swaps across multiple networks. Other significant integrators include OpenOcean, LI.FI (which powers swaps for MetaMask, Robinhood, Phantom, and Brave), Rango Exchange, Bitget Wallet, TokenPocket, and OneKey. THORSwap itself is powered by SwapKit, using it as the core technology stack for all cross-chain services.

## Conclusion: Infrastructure layer for multi-chain DeFi

SwapKit represents a fundamental infrastructure layer that abstracts the complexity of multi-chain DeFi into a developer-friendly interface. The platform's key innovation lies in enabling **single-signature cross-chain swaps** where users maintain full custody, need gas only on the originating chain, and complete complex multi-hop routes without manual intervention. By aggregating four major cross-chain protocols and eight-plus DEX aggregators, SwapKit delivers optimal pricing through competition while maintaining non-custodial security.

For BigQuery data analysis, the most critical schema considerations are the nested fee structures organized by chain, the legs arrays for tracking multi-stage transactions, the providers and subProviders arrays for understanding liquidity routing, and the standardized CHAIN.SYMBOL asset naming convention. The distinction between network fees (gas costs), affiliate fees (integrator revenue), SwapKit platform fees (10-15 bps on gas-to-stablecoin swaps), and slippage fees provides a complete picture of transaction economics. Understanding that quotes expire after 60 seconds, routes are ordered by best return, and multi-leg swaps require separate tracking per chain enables proper data interpretation.

The addition of NEAR Intents in June 2025 signals SwapKit's continued evolution toward gas abstraction and programmable cross-chain execution, positioning the platform as critical infrastructure for DeFi's multi-chain future. With battle-tested performance powering major wallets and exchanges, comprehensive liquidity aggregation across 30+ chains, and a proven developer experience reducing integration time from months to days, SwapKit has established itself as one of the most complete toolkits for cross-chain DeFi functionality.
